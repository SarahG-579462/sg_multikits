ACTION_DEFINE_ASSOCIATIVE_ARRAY 2DALIST// ASSOCIATIONS: column-label, is_transposed,
BEGIN //prompt, one two, loosen, restrict, sum, random, SMART, SKIP
  ~clastext~    => "0 0 0"//class strings
  ~kitlist~     => "1 0 0"//kit   strings
  ~kittable~    => "0 0 0"//kit races
  ~clasweap~    => "0 0 9"//(old) weapon proficiencies
  ~weapprof~    => "1 1 9"//weapon proficiencies
  ~abclsmod~    => "0 0 3"//kit roll modifiers
  ~abclasrq~    => "0 0 3"//kit roll requirements
  ~alignmnt~    => "0 0 4"//kit alignments
  ~backstab~    => "0 0 3"//kit backstab
  ~sneakatt~    => "0 0 3"//kit sneak attack     (3e)
  ~crippstr~    => "0 0 3"//kit crippling strike (3e)
  ~thiefskl~    => "0 0 5"//kit thief skills available
  ~thiefscl~    => "0 1 3"//kit thief skills per level (COLUMN-WISE)
  ~clsrcreq~    => "0 0 4"//kit racial requirements
  ~clascolr~    => "0 1 6"//kit colours (COLUMN-WISE)
  ~clasiskl~    => "0 1 5"//kit starting scores (COLUMN-WISE)
  ~clasthac~    => "0 1 5"//kit thaco bonus (COLUMN-WISE)
  ~clswpbon~    => "0 0 8"//kit weapon bonuses (APR, UNARMED APR, UNPROFICIENT THAC0)
END
DEFINE_ACTION_FUNCTION backup_2da
BEGIN
  ACTION_PHP_EACH "2DALIST" AS "2DA" => "OPTIONS" BEGIN
    COPY_EXISTING "%2DA%.2da" ~override~
      PATCH_PRINT "BACKED UP %2DA%.2DA"
  END
END

DEFINE_PATCH_FUNCTION read_2da_header_now
  RET_ARRAY
    output
  BEGIN
    SET numlines = 0
    SET curroffset = 0
    SPRINT currline ""
    WHILE (numlines < 3) BEGIN
      READ_BYTE  curroffset currbyte
      READ_ASCII curroffset currstr ( 1 )
      SET curroffset += 1
      SPRINTF currline EVAL "%currline%%s" ("%currstr%")
      PATCH_IF (currbyte == 0x0a) BEGIN
        SET numlines += 1
        SPRINT newline "%currline%"
        SPRINT currline ""
      END
    END
    // send to an ass-array
    PATCH_DEFINE_ASSOCIATIVE_ARRAY output BEGIN END
    SET curroffset = 0
    SET numwords = 0
    SPRINT currword ""
    SET strlen = STRING_LENGTH "%newline%"
    INNER_PATCH "%newline%" BEGIN
      READ_ASCII curroffset laststr ELSE ~~ ( 1 )
      READ_BYTE  curroffset lastbyte ELSE 0x20
      SET curroffset += 1
      FOR (i=0;i < "%strlen%";i += 1) BEGIN
        READ_ASCII i currstr  ELSE ~~ ( 1 ) NULL
        READ_BYTE  i currbyte ELSE 0x20

        PATCH_IF (currbyte != 0x20  AND (i != "%strlen%" - 1)) BEGIN // if not a space, append.
          SPRINTF currword EVAL "%currword%%s" ("%currstr%")
        END
        //if a space, check if last was a chr.
        PATCH_IF (lastbyte != 0x20) AND ((currbyte == 0x20) OR (i == "%strlen%" - 1)) BEGIN
          SET numwords += 1
          SET $output("%currword%") = "%numwords%" //append word

          //PATCH_PRINT "%currword%"
          SPRINT currword "" //reset word
        END
        SET lastbyte = "%currbyte%"
        SPRINT laststr "%currstr%"
      END
    END
END


DEFINE_ACTION_FUNCTION 2da_to_asarray
  INT_VAR name_col = 0
  STR_VAR filename = ~~
          fileto = ~override~
  RET_ARRAY
    rows
    cols
    outtable2
    nrows
    ncols
  BEGIN
    ACTION_DEFINE_ASSOCIATIVE_ARRAY "rows" BEGIN END
    ACTION_DEFINE_ASSOCIATIVE_ARRAY "cols" BEGIN END
    ACTION_DEFINE_ARRAY "outtable2" BEGIN END
    COPY_EXISTING "%filename%" "%fileto%"

      COUNT_2DA_COLS "ncols"
      READ_2DA_ENTRIES_NOW "outtable" "%ncols%"
      SET nrows = "%outtable%"
      // dumb but weidu is weidu I guess
      FOR (row=0; row < "%nrows%"; row += 1) BEGIN
        FOR (col=0; col < "%ncols%"; col += 1) BEGIN
          READ_2DA_ENTRY_FORMER "outtable" "%row%" "%col%" tmp
          SPRINT $outtable2("%row%" "%col%") "%tmp%"
        END
      END
      LPF read_2da_header_now RET_ARRAY "cols" = output END

      FOR (row = 0; row < "%nrows%"; row += 1) BEGIN
        SPRINT "name" $outtable2("%row%" "%name_col%")
        SET $"rows"("%name%") = row
      END

      BUT_ONLY

END



DEFINE_ACTION_MACRO GET_2DAS
BEGIN
  //override 2das:
  

  ACTION_PHP_EACH "2DALIST" AS "2da" => "col_id" BEGIN
    
    LAF SUBSTRING INT_VAR start = 0 length = 1 STR_VAR string = EVAL "%col_id%" RET "col_id" = substring END
    LAF 2da_to_asarray
      INT_VAR name_col = EVAL "%col_id%"
      STR_VAR filename = ~%2da%.2da~
      RET_ARRAY ~%2da%_rows~ = rows
                ~%2da%_cols~ = cols
                ~%2da%~ = outtable2
    END

  END

  ACTION_DEFINE_ASSOCIATIVE_ARRAY 2DALIST_MOD
  BEGIN
    ~multi_grid~ => "0 0"
  END

  ACTION_PHP_EACH "2DALIST_MOD" AS "2da" => "col_id" BEGIN
    LAF SUBSTRING INT_VAR start = 0 length = 1 STR_VAR string = EVAL "%col_id%" RET "col_id" = substring END
    LAF 2da_to_asarray
      INT_VAR name_col = EVAL "%col_id%"
      STR_VAR filename = ~%MOD_FOLDER%/lib/%2da%.2da~
              fileto = ~~
      RET_ARRAY ~%2da%_rows~ = rows
                ~%2da%_cols~ = cols
                ~%2da%~ = outtable2
    END
  END

END


DEFINE_ACTION_FUNCTION merge_2da
INT_VAR
  column = 0
  restrict12 = 0
  restrict23 = 0
STR_VAR
  filename = ~~
  kit1   = ""
  kit2   = ""
  kit3   = ""
  class1 = ""
  class2 = ""
  class3 = ""
  multi  = ""
RET output
    restrict12
    restrict23
BEGIN

  OUTER_SPRINT row1str ""
  OUTER_SPRINT row2str ""
  OUTER_SPRINT row3str ""
  OUTER_SPRINT rowstrmulti ""
  OUTER_SPRINT output ""
  OUTER_SPRINT idstr ""

  ACTION_IF NOT column BEGIN
    OUTER_SPRINT myrow "rows"
    OUTER_SPRINT mycol "cols"
  END ELSE BEGIN
    OUTER_SPRINT myrow "cols"
    OUTER_SPRINT mycol "rows"
  END

  OUTER_SPRINT rowkit1 EVAL "%%filename%_%myrow%_%kit1%%"
  OUTER_SPRINT rowkit2 EVAL "%%filename%_%myrow%_%kit2%%"
  OUTER_SPRINT rowkit3 EVAL "%%filename%_%myrow%_%kit3%%"
  
  OUTER_SPRINT rowcls1 EVAL "%%filename%_%myrow%_%class1%%"
  OUTER_SPRINT rowcls2 EVAL "%%filename%_%myrow%_%class2%%"
  OUTER_SPRINT rowcls3 EVAL "%%filename%_%myrow%_%class3%%"
  OUTER_SPRINT rowmulti EVAL "%%filename%_%myrow%_%multi%%"

  
  ACTION_PHP_EACH "%filename%_%mycol%" AS "colname" => "colnum" BEGIN
    ACTION_IF column BEGIN
      OUTER_SET valkit1  = (IS_AN_INT EVAL "%rowkit1%") ? $"%filename%"("%colnum%" "%rowkit1%") : 0 - 1 
      OUTER_SET valkit2  = (IS_AN_INT EVAL "%rowkit2%") ? $"%filename%"("%colnum%" "%rowkit2%") : 0 - 1 
      OUTER_SET valkit3  = (IS_AN_INT EVAL "%rowkit3%") ? $"%filename%"("%colnum%" "%rowkit3%") : 0 - 1 

      OUTER_SET valcls1  = (IS_AN_INT EVAL "%rowcls1%") ? $"%filename%"("%colnum%" "%rowcls1%") : 0 - 1 
      OUTER_SET valcls2  = (IS_AN_INT EVAL "%rowcls2%") ? $"%filename%"("%colnum%" "%rowcls2%") : 0 - 1 
      OUTER_SET valcls3  = (IS_AN_INT EVAL "%rowcls3%") ? $"%filename%"("%colnum%" "%rowcls3%") : 0 - 1 

      OUTER_SET valmulti = (IS_AN_INT EVAL "%rowmulti%") ? $"%filename%"("%colnum%" "%rowmulti%") : 0 - 1 
    END ELSE BEGIN                    
      OUTER_SET valkit1  = (IS_AN_INT EVAL "%rowkit1%") ? $"%filename%"("%rowkit1%" "%colnum%") : 0 - 1 
      OUTER_SET valkit2  = (IS_AN_INT EVAL "%rowkit2%") ? $"%filename%"("%rowkit2%" "%colnum%") : 0 - 1 
      OUTER_SET valkit3  = (IS_AN_INT EVAL "%rowkit3%") ? $"%filename%"("%rowkit3%" "%colnum%") : 0 - 1 
      
      OUTER_SET valcls1  = (IS_AN_INT EVAL "%rowcls1%") ? $"%filename%"("%rowcls1%" "%colnum%") : 0 - 1 
      OUTER_SET valcls2  = (IS_AN_INT EVAL "%rowcls2%") ? $"%filename%"("%rowcls2%" "%colnum%") : 0 - 1 
      OUTER_SET valcls3  = (IS_AN_INT EVAL "%rowcls3%") ? $"%filename%"("%rowcls3%" "%colnum%") : 0 - 1 

      OUTER_SET valmulti = (IS_AN_INT EVAL "%rowmulti%") ? $"%filename%"("%rowmulti%" "%colnum%") : 0 - 1 
    END
    
    LAF merge_item 
      INT_VAR 
        mergetype1 = restrict12 
        mergetype2 = restrict23
        valkit1
        valkit2 
        valkit3
        
        valcls1
        valcls2
        valcls3
        
        valmulti
      STR_VAR
        tablename
        colname
      RET
        rowout = output
    END
    
    OUTER_SPRINT row1str "%row1str% %valkit1%"
    OUTER_SPRINT row2str "%row2str% %valkit2%"
    OUTER_SPRINT rowstrmulti "%rowstrmulti% %valmulti%"
    ACTION_IF FLAG_TRIPLECLASS BEGIN OUTER_SPRINT row3str "%row3str% %valkit3%" END
    OUTER_SPRINT idstr   "%idstr% %colname%"
    OUTER_SPRINT output "%output% %rowout%"
  END
  ACTION_IF FLAG_TRIPLECLASS BEGIN
  PRINT "%filename%:
%rowstrmulti% (%multi%)
%row1str% (%class1%-%kit1%)
%row2str% (%class2%-%kit2%)
%row3str% (%class3%-%kit3%)
%output%"
  END ELSE BEGIN         
  PRINT "%filename%:
%rowstrmulti% (%multi%)
%row1str% (%class1%-%kit1%)
%row2str% (%class2%-%kit2%)
%output%"
  END
END

DEFINE_ACTION_FUNCTION merge_item 
  INT_VAR 
    mergetype1 = 0 
    mergetype2 = 0
    valkit1  = 0 - 1
    valkit2  = 0 - 1
    valkit3  = 0 - 1
    valcls1  = 0 - 1
    valcls2  = 0 - 1
    valcls3  = 0 - 1
    valmulti = 0 - 1

  STR_VAR 
    tablename = ""
    colname   = ""
  RET
    output
BEGIN
  LAF DEBUGPRINT INT_VAR level = 2 STR_VAR func = EVAL "merge_item: %mergetype1% %mergetype2% 
    valkit1  = %valkit1%
    valkit2  = %valkit2%  
    valkit3  = %valkit3%  
    valcls1  = %valcls1%  
    valcls2  = %valcls2%  
    valcls3  = %valcls3%  
    valmulti = %valmulti% 
    tablename = %tablename%
    colname   = %colname%  
    " END
  ACTION_IF (mergetype1 == 6 AND mergetype2 == 6) BEGIN// need to do this one individually to get an even 33% distribution
    OUTER_SET random3 = RANDOM (0 2)
    ACTION_MATCH random3
      WITH
        0 BEGIN OUTER_SET output = valkit1 END
        1 BEGIN OUTER_SET output = valkit2 END
        2 BEGIN OUTER_SET output = valkit3 END
        DEFAULT
    END
  END ELSE BEGIN
    ACTION_MATCH mergetype1
      WITH
        1 BEGIN /* valkit1 priority*/  LAF merge_first    INT_VAR val1 = valkit1 val2 = valkit2 RET output = output END END
        2 BEGIN /* valkit2 priority*/  LAF merge_second   INT_VAR val1 = valkit1 val2 = valkit2 RET output = output END END
        3 BEGIN /* loosen like FM */   LAF merge_loosen   INT_VAR val1 = valkit1 val2 = valkit2 RET output = output END END
        4 BEGIN /* restrict like C*/   LAF merge_restrict INT_VAR val1 = valkit1 val2 = valkit2 RET output = output END END
        5 BEGIN /* sum of c1 & c2 */   LAF merge_sum      INT_VAR val1 = valkit1 val2 = valkit2 RET output = output END END
        6 BEGIN /* randomize      */   LAF merge_random   INT_VAR val1 = valkit1 val2 = valkit2 RET output = output END END
        7 BEGIN /* smart select   */ FAIL ~unimplemented: smart select~ END
        8 BEGIN /* clswpbon~ */ LAF merge_clswpbon INT_VAR valkit1 valkit2 STR_VAR colname = EVAL "%colname%" RET output = merge END END
        9 BEGIN LAF merge_weapprof INT_VAR valkit1 valkit2 valkit3 valcls1 valcls2 valcls3 valmulti
                    RET output = merge END
          END
      DEFAULT FAIL ~unknown restriction given: mergetype1 = %mergetype1%~
    END
    
    ACTION_IF (mergetype2 != 0) AND
              (mergetype2 != 9) BEGIN
      LAF merge_item 
        INT_VAR 
        mergetype1 = mergetype2 
        valkit1 = output 
        valkit2 = valkit3
        valcls1 valcls2 valcls3 valmulti
        STR_VAR 
        tablename
        colname  
        RET 
        output = output 
      END
    END
  END
  OUTER_SET output = (output < 0) ? 0 : output
END

DEFINE_ACTION_FUNCTION merge_first INT_VAR val1 = 0 val2 = 0 RET output BEGIN
  OUTER_SET output = ((val1 >  0)                  ) ? (val1 + val2 + (ABS (val1 - val2))) / 2 : 0
END

DEFINE_ACTION_FUNCTION merge_second INT_VAR val1 = 0 val2 = 0 RET output BEGIN
  OUTER_SET output = (                  (val2 >  0)) ? (val1 + val2 + (ABS (val1 - val2))) / 2 : 0
END

DEFINE_ACTION_FUNCTION merge_loosen INT_VAR val1 = 0 val2 = 0 RET output BEGIN
  OUTER_SET output = ((val1 >  0) OR  (val2 >  0)) ? (val1 + val2 + (ABS (val1 - val2))) / 2 : 0
  LAF DEBUGPRINT INT_VAR level = 3 STR_VAR func = EVAL "merge_loosen: %val1% X %val2% = %output%" END

END

DEFINE_ACTION_FUNCTION merge_restrict INT_VAR val1 = 0 val2 = 0 RET output BEGIN
  OUTER_SET output = ((val1 >  0) AND (val2 >  0)) ? (val1 + val2 + (ABS (val1 - val2))) / 2 : 0
END

DEFINE_ACTION_FUNCTION merge_sum INT_VAR val1 = 0 val2 = 0 RET output BEGIN
  OUTER_SET output = ((val1 >  0) AND (val2 >  0)) ? (val1 + val2) : (val1 + val2 + (ABS (val1 - val2))) / 2
END

DEFINE_ACTION_FUNCTION merge_random INT_VAR val1 = 0 val2 = 0 RET output BEGIN
  OUTER_SET output = RANDOM (0 1) ? val1 : val2
END

DEFINE_ACTION_FUNCTION merge_minima INT_VAR val1 = 0 val2 = 0 RET output BEGIN
  OUTER_SET output = ((val1 >  0) AND (val2 >  0)) ? (val1 + val2 - (ABS (val1 - val2))) / 2 : 0 - 1
END

DEFINE_ACTION_FUNCTION merge_clswpbon
INT_VAR 
valkit1 = 0 - 1
valkit2 = 0 - 1
STR_VAR colname = ""
RET merge
BEGIN
  LAF DEBUGPRINT INT_VAR level = 2 STR_VAR func = EVAL "merge_clswpbon: %colname% %valkit1% %valkit2%" END
  OUTER_SET merge = 0
  ACTION_MATCH "%colname%"
    WITH ~GETS_PROF_APR~    BEGIN LAF merge_loosen   INT_VAR val1 = valkit1 val2 = valkit2 RET merge = output END END
         ~UNARMED_DIVISOR~  BEGIN LAF merge_loosen   INT_VAR val1 = valkit1 val2 = valkit2 RET merge = output END END
         ~ZERO_SKILL_THAC0~ BEGIN LAF merge_minima   INT_VAR val1 = valkit1 val2 = valkit2 RET merge = output END END
    DEFAULT  FAIL ~ERROR: BAD COLUMN GIVEN TO MERGE_CLSWPBON~
  END
  LAF DEBUGPRINT INT_VAR level = 2 STR_VAR func = EVAL "merge_clswpbon: %colname% mergeval: %merge%" END

END

DEFINE_ACTION_FUNCTION merge_weapprof 
INT_VAR //say FMC Kensai sling
valkit1  = 0 - 1
valkit2  = 0 - 1
valkit3  = 0 - 1
valcls1  = 0 - 1
valcls2  = 0 - 1
valcls3  = 0 - 1
valmulti = 0 - 1
RET
merge 
BEGIN 
  OUTER_SET diff_1 = (valkit1 >= 0) ? valcls1 - valkit1  : valcls1
  OUTER_SET diff_2 = (valkit2 >= 0) ? valcls2 - valkit2  : valcls2
  OUTER_SET diff_3 = (valkit3 >= 0) ? valcls3 - valkit3  : valcls3
  //OUTER_SET m = ARGMIN(diff_%i%)
  //OUTER_SET M = ARGMAX(diff_%i%)
  OUTER_SET diffmin = 0
  OUTER_SET diffmax = 0
  OUTER_FOR (i = 1;i <= 3; i += 1) BEGIN
    OUTER_SPRINT currcls EVAL "%valcls%i%%"
    OUTER_SPRINT currkit EVAL "%valkit%i%%"
    OUTER_SET EVAL "diff%i%" = "%currcls%" - "%currkit%"
    ACTION_IF EVAL "%diff%i%%" <= diffmin BEGIN
      OUTER_SET ind_min = i
      OUTER_SET diffmin = EVAL "%diff%i%%"
      OUTER_SET kitmin  = EVAL "%valkit%i%%"
    END
    
    ACTION_IF EVAL "%diff%i%%" >= diffmax BEGIN
      OUTER_SET ind_max = i
      OUTER_SET diffmax = EVAL "%diff%i%%"
      OUTER_SET kitmax  = EVAL "%valkit%i%%"
    END
  END
  
  OUTER_SET merge = EVAL "%valmulti%"
  // if ANY diff restricts, i.e. is positive, choose that restriction.
  ACTION_IF diffmax > 0 BEGIN // i.e. a kit restricts
    OUTER_SET merge = merge > kitmax ? kitmax : merge // take the heaviest restriction, OR multi, if it is lower.
  END ELSE BEGIN
    // otherwise, if a kit gives a bonus prof, give that bonus
    ACTION_IF diffmin < 0 BEGIN // 
      OUTER_SET merge = merge < kitmin ? kitmin : merge
    END
  END
END 